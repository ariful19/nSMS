# <a name="header"></a><a name="content"></a><a name="x392a8de15dac513eb7c6cb43a3e3a2c1a6ce7ff"></a>Migration Plan for School\_Queens to Vue/Lit, Express.js, and SQLite/MySQL
## <a name="overview-and-objectives"></a>Overview and Objectives
The **School\_Queens** system (currently an ASP.NET WebForms app) will be migrated to a modern web stack using **Node.js/Express** for the backend, **Vue 3 + Lit** for the frontend, and **SQLite/MySQL** for the database. The goal is to rebuild the application with flexibility for redesign and improvements, while preserving (and enhancing) functionality. Key objectives include:

- **Full Redesign & Flexibility:** Re-architect the system for maintainability and scalability. We will not do a direct line-by-line port, but rather **redesign** components where beneficial. This includes simplifying the tech stack (e.g. removing legacy ASP.NET patterns) and improving the database schema as needed for clarity and performance.
- **No Stored Procedures:** The current system relies heavily on SQL stored procedures for data operations[\[1\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/App_Code/DatabaseManager.cs#L116-L124). We will eliminate these, implementing all business logic in the application layer (Node/Express) or using an ORM. This “no SP” approach improves portability (works with SQLite/MySQL) and makes the code easier to maintain and evolve.
- **Session-Based Authentication:** Replace the legacy ASP.NET membership/Forms Auth (which uses SqlMembershipProvider and related tables[\[2\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config#L2-L5)) with a **session-based auth** system in Express. User credentials will be stored in a custom users table, with sessions (via cookies) managing login state.
- **MPA + JS Islands Architecture:** Instead of a single-page app, we'll use a **Multi-Page Application (MPA)** approach with server-rendered pages, enhanced by **JavaScript islands** for rich interactivity. This means each page is delivered fully rendered (improving initial load and SEO)[\[3\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=,hydration%20or%20the%20islands%20architecture), and we inject Vue/Lit components on parts of the page that need dynamic behavior (achieving “deeper usage” without a full SPA reload). In practice, most pages will work with minimal JS, but interactive components (forms, dashboards, etc.) will mount as needed, providing a SPA-like feel in isolated sections[\[4\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=,Highly%20customized%20data%20filtering%2Fsorting).
- **Codex Web Development Environment:** Ensure the app can run in a cloud/web development environment (like CodeX) with minimal setup. This means using **SQLite** as the dev database (no external service needed) and providing easy initialization (scripts or migrations) so the app is immediately runnable and testable. The same codebase will support **MySQL** in production with configuration changes. We will choose modern, widely-supported libraries and frameworks (“best available”) to maximize development productivity and future maintainability.
## <a name="tech-stack-architecture"></a>Tech Stack & Architecture
**Backend:** **Node.js** with **Express.js** will serve as the web server and API layer. Express is lightweight and flexible, allowing us to implement an MPA structure easily. We will structure the backend in a MVC/service style: routes for each module (students, teachers, etc.), controllers or handlers for business logic, and database access via models/ORM.

- **Session & Auth:** Use **express-session** middleware for session management (storing session IDs in cookies, with server-side session storage). Sessions will be configured to use a SQLite-based store in development for persistence (e.g. using connect-sqlite3 or similar), and a MySQL-compatible store or centralized solution in production. This ensures login state is preserved without requiring the user to re-authenticate on each request. We’ll implement login, logout, and role-based access control using this session mechanism. (The old system’s Forms Authentication cookies will be replaced by Express sessions.)
- **RESTful APIs:** In addition to serving HTML pages, Express will expose JSON endpoints for dynamic interactions (e.g. an autocomplete search, or saving form data asynchronously). This will support the JS components on the frontend. All API routes will respect the session auth (ensuring a valid session for protected data).
- **View Engine / Templates:** For server-side rendering, we will likely use a templating engine such as **EJS** or **Pug** to generate HTML on the server. This allows us to inject dynamic data into pages and reuse layout components (like header, footer). Using server-rendered pages ensures *“the user sees HTML right away”* (improving perceived performance and SEO)[\[3\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=,hydration%20or%20the%20islands%20architecture). Each page corresponds to a route in Express; on a request, the controller will fetch required data from the DB and render an HTML page via the template.
- **Architecture Pattern:** The app will follow an MPA with an **“islands”** enhancement approach. Most of the page markup is rendered server-side (possibly with some template includes for common parts). Where interactivity is needed, we integrate Vue or Lit components. This approach is inspired by the islands architecture (as seen in frameworks like Astro), where predominantly static pages have pockets of JS-driven interactivity[\[5\]](https://vuejs.org/guide/extras/ways-of-using-vue#:~:text=%2A%20A%20multi,inside%20static%20HTML)[\[6\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=1.%20Use%20a%20Node,only%20where%20necessary). The benefit is that we drastically reduce overall JS load by only using it where necessary, while still achieving a dynamic user experience in those parts.

**Frontend:** **Vue 3** and **Lit** will be used in combination to build the client-side experience. We will leverage Vue for richer, stateful components and use Lit to create reusable web components, as needed:

- **Vue 3:** Vue will be utilized in an **incremental, progressive enhancement** manner. Rather than a single monolithic SPA, we'll create small Vue apps or components that bootstrap on specific page elements. For example, a complex form with validation or a dashboard widget can be a Vue component that mounts on a div within an otherwise static page. Vue’s official guidance notes that this standalone integration is a valid approach – Vue can be dropped in as a “declarative replacement for jQuery” on pages where needed[\[7\]](https://vuejs.org/guide/extras/ways-of-using-vue#:~:text=Vue%20can%20be%20used%20as,of%20jQuery%20in%20such%20cases). We can include Vue via a build (bundling with Vite) or via CDN in dev for simplicity, then mount a createApp on specific DOM elements.
- **Lit (LitElement):** Lit will be used to build **standard Web Components** for UI elements that we want to reuse across pages or even outside this app. Lit is ideal here because its components are framework-agnostic and lightweight. *“Every Lit component is a standard web component... usable in any HTML environment, with any framework or none”[\[8\]](https://lit.dev/docs/#:~:text=The%20first%20thing%20to%20know,framework%20or%20none%20at%20all)*. We will create custom elements (e.g. <user-avatar>, <data-table>, or a custom datepicker, etc.) as Lit components. These can be embedded in our server-rendered HTML directly and will hydrate themselves. Lit’s reactive properties and templating make it easy to keep state within these components without a larger framework overhead[\[9\]](https://lit.dev/docs/#:~:text=Lit%20is%20a%20simple%20library,building%20fast%2C%20lightweight%20web%20components). Using Lit ensures **interoperability** – if we ever needed to embed these in another app or share components between Vue and non-Vue parts, it’s seamless[\[8\]](https://lit.dev/docs/#:~:text=The%20first%20thing%20to%20know,framework%20or%20none%20at%20all).
- **Integration of Vue & Lit:** We will carefully delineate when to use each:
- Use **Lit** for design-system-like components or isolated widgets that don't need Vue's full ecosystem. Lit components can even be used inside Vue if needed (since they are HTML elements). For example, a custom <modal-dialog> or <rich-text-editor> could be Lit-based and used anywhere.
- Use **Vue** for parts of pages that involve complex data binding with the server or user input flows. Vue's reactivity and component system will handle things like multi-step forms, interactive grids (filtering/sorting), or conditional UI that would be cumbersome with only web components. By confining Vue to specific islands, we avoid making the entire app a SPA, but we still deliver a rich experience where it counts[\[4\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=,Highly%20customized%20data%20filtering%2Fsorting).
- **Building & Tooling:** We will set up a front-end build process using **Vite** (a fast modern bundler). The front-end codebase can be organized into:
- A **Vue components** directory (with .vue single-file components or composition API scripts for each interactive piece).
- A **Lit components** directory for web component classes.
- Each page (or group of pages) will have an entry-point JS file. For example, students.js that imports necessary Vue/Lit components and mounts or defines them. Vite can produce multiple output bundles (one per page or per feature), which we will include via script tags on the corresponding HTML pages. This way, pages only load the JS needed for that page (aligning with the islands strategy).
- **Styling and UI:** For a modern responsive design, we'll leverage a CSS framework. The choice could be **Tailwind CSS** (with a UI kit like DaisyUI) or **Bootstrap 5** – whichever is “best available” for fast development. Tailwind/DaisyUI is attractive because it provides prebuilt components purely through CSS classes (minimal JS)[\[10\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=DaisyUI%20is%20built%20on%20Tailwind,JavaScript%20for%20its%20core%20functionality), which aligns with our goal to keep baseline pages lightweight. We will apply a consistent theme and ensure the UI is mobile-responsive. Common layout components (header, sidebar, footer) can be included via the server templates, and interactive UI controls (dropdowns, modals) can be either pure CSS or implemented as Lit components if they require logic.

**Database:** In development, we use **SQLite**, and in production, **MySQL**. We will design the schema to be compatible with both. Key points:

- Use an **ORM or Query Builder** for database access to abstract differences between SQLite and MySQL. A modern choice is **Prisma** or **Knex/Objection** or **Sequelize**. For example, using an ORM will allow defining the models (tables) in a single place and automatically handle differences (Prisma supports SQLite and MySQL with the same schema definitions). This also provides migrations to set up the schema. We will choose a well-supported tool (e.g. Prisma for its developer experience or Knex for simplicity).
- The database schema will be **redesigned** as needed. The current schema (found in the repository’s schema scripts) includes tables like st\_Person, tr\_Teacher, various lookup tables (bs\_Gender, bs\_Religion, etc.), and ASP.NET membership tables (aspnet\_Users, aspnet\_Roles, etc.)[\[11\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L72-L81)[\[12\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L106-L115). We will streamline this:
- **User & Auth Tables:** Introduce a users table for application login accounts (with fields: id, username, password\_hash, email, etc.). Passwords will be stored hashed (using bcrypt). We’ll drop the old membership schema (aspnet\_Users, etc.) entirely and migrate any needed data (or simply have admins re-create accounts) since “no migration needed” was indicated. For roles, create a simple roles table and a join table user\_roles (or embed a role field in users if the system is simple). This replaces the aspnet\_Roles and aspnet\_UsersInRoles usage[\[13\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L212-L217) with a simpler, custom solution.
- **Person/Student/Teacher:** The old design had a notion of st\_Person for common info and tr\_Teacher for teacher-specific info (and likely a student equivalent, e.g. perhaps ad\_Student or similar). In the new design, we have flexibility. We can maintain a similar separation (e.g. a people table for basic demographics, linked to either a students table or staff table for role-specific details). However, since each student or teacher likely also has a user account in the new system (for portal access), we might merge the concept of person and user for simplicity – i.e., the users table could store the common profile info too. **Plan:** Create a students table and a staff (or teachers) table with fields specific to those roles (like enrollment details for students, employment details for staff). They can reference the users table for their account, or if accounts aren’t needed for all, reference a common person profile. This will be discussed and optimized – the aim is to reduce redundancy and complexity. We will certainly include fields like those in st\_Person (name, DOB, contacts, etc.) and those in tr\_Teacher (designation, join date, employee ID/PIN, etc.)[\[14\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L117-L125)[\[15\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L189-L197).
- **Look-up Tables:** The current DB has many lookup tables (Gender, Religion, BloodGroup, Qualification, etc.) which were used via IDs[\[11\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L72-L81). We will keep these as separate tables for flexibility (so new values can be added via UI in the future). They will be seeded with initial values (e.g. the standard list of genders, etc.). In some cases, a simpler enum might suffice (for Gender), but to minimize hard-coding, we’ll likely preserve the lookup tables approach. We will also include tables for classes, sections, subjects, grades, as needed by the academic module (these likely exist as tbl\_Grade, tbl\_Level in the old schema[\[16\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L99-L103)[\[17\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L101-L105), which we can rename and restructure).
- **Academic Records:** Design tables for **student enrollment** (which student is in which class/section/year), **subjects/courses**, **exam results** (marks, grades per subject), and **attendance** if applicable. For example, a table classes (or sections) with class info, a join table student\_classes (if many-to-many), subjects, student\_marks (with student, subject, exam, mark, grade etc.), etc. We will draw from the old system’s features: since it had a *MarkSheet* report, there must be a way to store marks/grades. We’ll ensure the schema supports that (perhaps an exams table, and a results table).
- **Fees Management:** The presence of a Fees module (e.g. Pages/Fees/PaymentSlip.aspx.cs) suggests tables for fees or invoices. We will include tables like fees (or invoices/payments), linking students to fee records (amount, date, etc.), and possibly a fee\_structure table for predefined fee categories. This can be redesigned for clarity (e.g. splitting fees into payments and categories).
- **Library Module:** The old system has a library page (Issue and Return Books). We will design tables such as library\_books (catalog of books), library\_transactions (to record issues/returns, linking student/staff, book, date out, date in). We’ll incorporate necessary fields like book status, due dates, etc.
- **Other Modules:** Any other modules (e.g. news/events, as hinted by Pages/User/News.aspx and an Event DAO) will get corresponding tables (e.g. news or events). Also, if the old app had a concept of campus (the script references bs\_CampusName[\[18\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L92-L95)), we’ll include a campuses table to support multi-campus data segregation.
- We will **avoid stored procedures entirely** in the new database. Instead, all CRUD operations will be done via the application code using parameterized queries or ORM methods. The old DatabaseManager class forced all queries through stored procs[\[1\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/App_Code/DatabaseManager.cs#L116-L124)[\[19\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/App_Code/DatabaseManager.cs#L156-L164); in our Node app, we’ll handle things in JavaScript, making the flow easier to trace and adjust. Complex operations (like the multi-step insert of person and teacher in the old system[\[14\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L117-L125)[\[15\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L189-L197)) will be implemented in code (within transaction scopes if needed for integrity). This also means business rules can be written in JS, benefiting from source control and not requiring DB deployments to change.
- **Migration and Seed:** Since we are not doing an automated data migration from the old system (the new database can be fresh), we will write migration scripts or use the ORM’s migration feature to create all tables. Additionally, we will prepare a **seed script** for development: e.g. create an initial admin user, sample students/teachers, and lookup data. This will help quickly populate the SQLite DB in the CodeX environment for testing. For MySQL production, the same migration can be run to set up the schema, and possibly a way to import any existing data if needed (if the school wants to carry over some records, a custom import might be done separately).
## <a name="backend-implementation-plan-express.js"></a>Backend Implementation Plan (Express.js)
We will implement the backend in a structured, modular fashion. The steps and components of the backend are:

1. **Project Setup:** Initialize a Node.js project with Express. Set up the basic app structure:
1. Create an app.js (or server.js) to initialize Express, apply middleware (session, JSON/body parsers, static file serving, etc.), and define the route mounting.
1. Create directories: routes/ for route definitions, controllers/ for route handlers logic, models/ for database access (if using an ORM, this might be where model definitions go, or a separate prisma/ schema file if Prisma).
1. Set up configuration management (for example, using environment variables or a config file to distinguish dev vs prod DB settings, secret keys, etc.). In CodeX dev, it will use SQLite; in production, it will use MySQL credentials.
1. **Session & Auth Middleware:** Configure **express-session** with a session store:
1. In dev, use a file-based SQLite store (e.g. connect-sqlite3 or better-sqlite3-session-store) so that sessions persist in the CodeX environment (memory store would reset on server restart, which is not ideal for testing). In production, we might use a MySQL-based store or Redis for scalability, but the code can switch based on NODE\_ENV.
1. Set session options: a secure cookie (HTTPS-only in prod), a reasonable expiration (and rolling expiration if desired for activity).
1. Implement an **authentication strategy**: likely a simple custom login. For example, a POST /login route that checks the users table for username/password match (using bcrypt compare). On success, store the user ID (and role) in req.session. On failure, respond with an error or redirect.
1. Protect routes using a middleware that checks req.session.userId. Define a function ensureLoggedIn to use on routes that require auth. If not logged in, redirect to login page.
1. If the app has roles (admin, teacher, etc.), implement an authorization middleware as well. For instance, store req.session.role or an array of roles, and have an ensureRole('admin') middleware for admin-only pages. This maps to how the old system likely had roles like “Accountant”, “Teacher”, etc., via membership roles[\[13\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L212-L217).
1. Provide a logout route that destroys the session and redirects to login.
1. **Routing Structure:** Define Express routes for each major module of the application:
1. **Public/General Pages:** e.g. login page, landing page, static info pages (about, news). These routes render corresponding views. (We’ll have a views/ directory with EJS/Pug templates for each page).
1. **User Dashboard:** If there’s a home or dashboard after login (the old app had Home.aspx), define /dashboard route which may show summary info.
1. **Admission/Students Module:** Routes like:
   - GET /students – list all students (accessible to admin or maybe teachers). Controller will fetch students (join with class info) and render a page (or possibly return JSON if the page loads data via XHR; we’ll choose server render for initial display).
   - GET /students/new – form to add a new student.
   - POST /students – form submission to create student (server will handle form post, create student (and user account if needed) in DB, then redirect or respond JSON).
   - GET /students/:id – view a student’s profile/details.
   - GET /students/:id/edit and POST /students/:id to update details.
   - Similar pattern for **Teachers/Staff** (/staff or /teachers endpoints).
1. **Academic Management:** Routes for classes, subjects, enrollment:
   - GET /classes – list classes (maybe by year/section).
   - POST /classes – create class, etc. (Or if classes are fairly static, maybe managed in config, but likely admin can create new classes/sections.)
   - Perhaps routes to assign students to classes (e.g. a form or a bulk upload).
   - **Marks/Exams:** Possibly a route for entering or viewing grades. E.g. GET /exams (list exam types or terms), GET /exams/:id/grades (enter/view grades for a class), etc., and corresponding POST to save grades. This part of the UI might benefit from a Vue component (for inline editing of a grid of marks).
   - **Attendance:** If needed, routes to mark attendance by date.
1. **Fees Module:** Routes like:
   - GET /fees – list fee records or a form to select a student to view/pay fees.
   - GET /fees/:studentId – show that student’s fee ledger.
   - POST /fees/:studentId/pay – record a payment.
   - Possibly routes for setting fee structures (if admin defines fee amounts).
   - We will ensure these routes correspond to functionalities (like generating a payment slip, which could be a PDF – we might integrate a PDF library or just show an HTML that can be printed).
1. **Library Module:** Routes such as:
   - GET /library/books – list of books.
   - POST /library/books – add a new book.
   - GET /library/issue – form/page to issue a book (e.g. select student and book).
   - POST /library/issue – create a borrow record.
   - GET /library/returns – list of borrowed books and a way to mark returns.
   - These pages might use a bit of JS for searching books or students quickly (for which we could have an API like GET /api/students?query=... that returns matches for an autocomplete).
1. **Communication/Notices:** If the old system had a news/announcement or SMS feature, we will add routes for that. For example, GET /notices for a list of announcements (news), and maybe POST /notices for admin to post a new announcement. If SMS integration is needed (the old app referenced an external web service for SMS[\[20\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config#L26-L31)), we can integrate a third-party SMS API in the Node app as needed, but that might be a phase 2 feature.
1. **Reports:** If there are reports (like MarkSheet, etc.), define routes to generate those. For instance, GET /reports/marksheet?class=X&exam=Y could generate a marksheet. We can generate reports either as HTML pages or as PDFs (Node has libraries like pdfkit or we can use headless Chrome to print to PDF). Ensuring these work in the new environment would be part of final testing.

Each route will have an associated controller function which handles the logic: - Fetch data via the models (using async/await to query the DB). - Perform any business logic (e.g. calculating aggregates, enforcing rules). - Either render a template with the data (for full page loads) or return JSON (for API endpoints). - Use proper error handling (try/catch and returning error pages or messages) and input validation (to avoid invalid data being processed). We can use a validation library (like Joi or express-validator) for checking request body data for create/update routes.

1. **Database Access Layer:** Implement the models or database utilities:
1. If using an ORM like Prisma: define the data model schema (in schema.prisma) for all tables (users, roles, students, etc. as discussed). Generate the client and use it in controllers for queries (e.g. prisma.student.findMany({...})).
1. If using a query builder (Knex): set up Knex config for SQLite and MySQL, and write simple data access functions or use an ORM on top (like Objection.js which uses Knex).
1. Ensure that all SQL queries are parameterized to prevent injection. The advantage of using a well-tested library here is that it handles that for us.
1. Write unit tests or simple scripts to verify that database operations work on both SQLite and MySQL (for example, test the schema migrations on both).
1. Implement **transactions** in code for multi-step operations where needed. For example, when creating a new student and user together, ensure either both user and student records are created or neither if one fails (wrap in a transaction). The old system did such multi-step operations via stored procedures and transactions[\[12\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L106-L115)[\[21\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L181-L189); we will replicate the atomicity using transaction support of our DB library.
1. **Backend Enhancements (Improvement Opportunities):**
1. **Logging & Error Handling:** Integrate a logging system (at least console logging, maybe a library like Winston) for server events and errors. Also, set up global error handlers in Express (for 404 and 500 errors) to handle unexpected issues gracefully.
1. **Security Hardening:** Use Helmet middleware for basic security headers. Ensure we properly handle authentication checks on all sensitive routes (no functionality is accessible without login that shouldn’t be). Also implement CSRF protection for form submissions (Express can use csurf middleware) since we are using cookies and sessions – this will protect against cross-site request forgery on state-changing operations.
1. **Internationalization (if needed):** The old app had resource files for English/Bangla content. For the new app, we can use a simpler i18n approach (like using JSON translation files and an i18n middleware or the Vue i18n for frontend strings). This can be planned if multilingual support is required from day one.
1. **Performance considerations:** Use caching where appropriate. For example, cache common lookup tables (like genders, religions) in memory on the server to avoid querying them repeatedly. Use pagination for list pages (students list, etc.) if the dataset is large, to avoid slow page loads.
1. **Phase-wise Development:** We will tackle the implementation in phases for manageability:
1. **Phase 1:** Set up the project, implement **user authentication** and basic layout. We’ll get the login/logout working with sessions, create the user table and an admin account. Also, create the base layout (navbar, etc.) and a landing page after login (even if mostly static). This ensures the skeleton of the app (authentication, sessions, template structure) is in place early.
1. **Phase 2:** Implement core **Student and Teacher management**. This includes the ability to create/read/update students and staff. Focus on forms for adding new students and teachers (which ties into user creation possibly), listing them, and editing. We will incorporate Vue components here for form validation and maybe dynamic fields (for example, if a “existing user” can be linked, etc., but since we create fresh, maybe simpler). Ensure these pages are functional and test with sample data.
1. **Phase 3:** Implement **Academic modules** (classes, subjects, enrollment, grades). Set up class and subject management (small forms to add classes/subjects). Then create functionality to assign students to classes (this could be a page where you pick a class and add students, or vice versa). Implement entering exam results: this is a candidate for a dynamic Vue-based grid where a teacher/admin can input many grades on one screen. Also implement viewing a marks report per student or class. Test calculations if any (like total, grade letter).
1. **Phase 4:** Implement **Fees module**. Create the data structures for fees and integrate a way to record payments. The UI might be a form where the admin selects a student and enters payment details (or multiple payments). Possibly generate a printable receipt (we can use an HTML template for a receipt – codex environment can print to PDF if needed, or just display).
1. **Phase 5:** Implement **Library module**. Set up book catalog management (simple CRUD for books) and the issue/return process. Perhaps use a Vue component for scanning (if they use ISBN or something) or just selection. Ensure that when a book is issued, it’s marked as unavailable until returned.
1. **Phase 6:** Implement any remaining features (News/Notices, Events, etc.) and polish. For notices, a simple CRUD of announcements that display on the user dashboard. For events, maybe a calendar or list of events. These might not need complex JS – standard forms and pages could do.
1. **Phase 7:** **Testing & QA:** Rigorously test each module end-to-end in the dev environment. Since we want it “perfectly runnable and testable” in CodeX, we’ll write automated tests for critical flows if possible (using something like Jest or Mocha for backend logic, and maybe Cypress or Playwright for integration tests on the UI if time permits). At minimum, we'll have a checklist to manually test: create a user, login, add student, edit student, add teacher, record a grade, record a fee payment, issue a book, etc., verifying the data is correctly saved and UI updates.
1. **Phase 8:** **Performance and Deployment Prep:** Optimize any slow queries (with proper indexing in MySQL, etc.), and prepare deployment scripts (like Dockerfile or a simple cloud setup). Also, migrate from SQLite to MySQL for staging/production by running migrations on a MySQL instance and testing again. Because we designed with no stored procs and used standard SQL, switching to MySQL should be smooth. We’ll also ensure environment variables or config allow easy switching of DB connection strings.

Throughout these phases, we will maintain **flexibility for improvements** – since we are not tied to the old design strictly, we can iterate on the UI/UX. For instance, if during development we find a certain workflow could be improved (fewer clicks, more feedback), we will adjust the design. Using Vue components in islands gives us freedom to enhance user experience without rewrites (e.g., we can add a bit of reactivity to a page if needed based on feedback).
## <a name="x2f748adbe244d56b2b2ffd063a747bc02ecc86f"></a>Frontend Implementation Plan (Vue & Lit Integration)
The frontend will be built to complement the backend’s MPA structure. Each page served by Express will be mostly static HTML with server-injected data, and we will attach frontend components where needed to make the page interactive. Here is the plan for developing the frontend:

- **Build Process:** Set up Vite (or an equivalent bundler) with support for Vue single-file components and for handling Lit components (which are plain JS/TS classes). Configure it for multiple entry points:
- e.g., src/main.js for global initialization (if any),
- src/pages/students.js for student-related page scripts,
- src/pages/fees.js for fees page, etc. These will output to public/js/ as separate files. The Express templates will include these <script src="/js/students.js" defer> tags on the relevant pages.
- Include the necessary polyfills if needed (for older browsers, though since we target modern likely fine).
- Also process CSS (if using Tailwind, set up PostCSS; if using Bootstrap, include it via imports).
- **Global Components and Layout:** Use Lit to create components used on many pages:
- For example, a <nav-bar> component for the navigation menu. This could be a Lit component that takes a property for the current user name or role and renders the menu accordingly. It can be included in the base layout template (<nav-bar user="${userName}" role="${role}"></nav-bar> in EJS, for instance). Lit will hydrate it on the client side (or we could even server-render a basic nav and let Lit only handle interactive bits like a toggling mobile menu).
- A <modal-dialog> Lit component for confirmation dialogs or forms in modal windows. Vue could also handle modals, but having a web component means it can be triggered from anywhere (possibly via an attribute or a small script).
- Any repeating form elements or special widgets (e.g. a date picker, rich text editor for notices, etc.) can be made as Lit components so they can be reused in different forms/pages.
- Because Lit components are encapsulated, they won't conflict with the rest of the page and can be used even on pages that are not heavy on Vue. This keeps with the principle that Lit components *“can be used in any HTML... or even applications built with other frameworks”[\[22\]](https://lit.dev/docs/#:~:text=web%20component,framework%20or%20none%20at%20all)* – so our Vue components or plain pages can all share them.
- **Vue Component Development:** Identify which pages need client-side interactivity that goes beyond what simple HTML forms can do:
- **Complex Forms:** For instance, the student admission form might benefit from Vue for features like dynamic form sections (perhaps show/hide guardian info if a certain field is set), inline validation feedback, etc. We will create a Vue component for the admission form. This component will manage its own state for form fields and perform validation (maybe using a library like Vuelidate or just custom watchers). On submit, it can either post the form traditionally or send an AJAX request to the server API. Using Vue here gives a smoother UX (no full page reload on validation errors, etc.).
- **Data Tables & Filtering:** Pages like student lists or fee lists might have search and filter functionality. We have two options: a) do filtering on the server via query parameters (with a form submission for search – a full reload), or b) load all data (or fetch via API) and filter on the client instantly. For better UX, we plan to incorporate a Vue component or small app on list pages. For example, on the Student List page, we can embed a Vue-driven search bar and list:
  - The initial HTML will list students (server-rendered to allow indexing and immediate display). We attach a Vue component to the list container which takes the initial list as props (we can embed the data as JSON in the page). The component enables dynamic filtering/sorting on that data without additional server calls. If the dataset is too large, we alternatively implement an API call on search input (which the Vue component calls debounced).
  - Similarly, a fees list or library book list can have client-side filtering with a Vue component.
- **Interactive Dashboards:** If an admin dashboard needs charts or summary stats, we can use Vue with a chart library (like Chart.js) to draw charts. The data for charts can be embedded in the page or fetched from an API.
- **Calendar or Schedule:** If scheduling (time table) is part of the system, a calendar component could be integrated. We might use a pre-made JS library for calendars, but Vue could wrap around it.
- **Inline Editing:** For something like entering marks for many students, we can create a Vue component that renders a table of students x subjects and allows the teacher to input scores. This can be done in a single page without navigating each student individually, leveraging Vue’s reactivity to update values and perhaps color-code pass/fail in real time. On save, it sends all data in one go to the server. This “marks entry” component would significantly enhance the usability for teachers compared to a basic form for each student.
- **File Uploads:** If the system has any file upload (perhaps for student photo upload or report attachments), a Vue component can manage the file preview and upload progress.

Each Vue component will be built as needed, registered globally (or locally in the page script) and mounted on a specific element that the server template defines. For example, the server might output <div id="student-list-app" data-props="{{jsonEncodedStudentList}}"></div> and the students.js script will do:

import { createApp } from 'vue';\
import StudentList from './components/StudentList.vue';\
const propsData = JSON.parse(document.getElementById('student-list-app').dataset.props);\
createApp(StudentList, propsData).mount('#student-list-app');

This way, the server provides initial data and Vue takes over to enhance interactivity. This approach aligns with the idea of **partial hydration**, where Vue components become “interactive islands” inside an otherwise static page[\[5\]](https://vuejs.org/guide/extras/ways-of-using-vue#:~:text=%2A%20A%20multi,inside%20static%20HTML).

- **Lit Component Development:** We will implement Lit components primarily for **reusable UI elements**:
- Lit components will be authored in TypeScript or JavaScript (depending on preference, TypeScript can help catch errors early). We’ll compile them down to JS with Vite.
- Example components:
  - <user-avatar>: Displays a user’s profile picture (or initials) and perhaps status. Used in nav bar or user lists.
  - <confirm-dialog>: A modal dialog that can be triggered to confirm an action (e.g. deletion). It could dispatch events back to the page when confirmed/canceled. This could be used universally when we need a confirmation prompt.
  - <data-table>: A wrapper for HTML table that could provide sortable columns when enriched. (Alternatively, use a lightweight library or Vue for sorting, but a web component could also do it and be reused for any dataset.)
  - <date-picker>: If needed, since handling dates is common in forms (DOB, etc.). There are existing web components or we could integrate a library. Using Lit we can integrate any external library within a component cleanly.
  - <rich-text-editor>: If admin posts news/announcements, a WYSIWYG editor could be a web component (or just use a library like Quill – but we could wrap Quill initialization in a Lit component for encapsulation).
- Each Lit component will be packaged so that it registers itself (using customElements.define). We can either have a single bundle for all Lit components that is included on every page (if size is small), or group them by usage. Perhaps a middle ground: one bundle for common components (used in navbar, etc.) loaded on all pages, and separate bundles for specific sections if there are heavy ones (like maybe the rich text editor only on the notices page).
- Lit components will improve maintainability by decoupling pieces of UI. They also allow non-Vue pages to have interactivity. For instance, the login page might not need Vue at all, but we could have a Lit <show-password-toggle> component on the password field to toggle visibility – no need to spin up a Vue app just for that trivial behavior.
- **Testing Frontend:** During development, we will test the Vue components in isolation (using Vue DevTools and running the dev server). We’ll also test Lit components by creating a simple HTML demo page for each to ensure they function independently. After integration, manual end-to-end testing will confirm that when navigating page to page, the components mount and unmount cleanly (Vue apps should destroy on page unload naturally since a full page refresh happens, so memory leaks are less concern than in SPA).
- **Progressive Enhancement Philosophy:** The application should not require JavaScript for basic operations whenever possible. For example, if JS is disabled, a user should still be able to submit forms (page reloads will occur, but at least functionality works). Our plan embraces this:
- All form submissions will have a server-side endpoint so they work without JS (Vue components may intercept to AJAX, but if JS is off, the <form action="..."> still submits to the server).
- All navigation is traditional links (e.g. a “Students” menu link goes to /students page load, not handled by client routing).
- Thus, the app is fully usable as an MPA, and JS is a progressive enhancement for better UX. This approach increases robustness and aligns with the MPA strategy.
- **UX Improvements:** We will incorporate modern UX patterns:
- Client-side validation and instant feedback (via Vue) to reduce user error frustration.
- Loading indicators for actions (e.g. show a spinner on a button when an AJAX save is in progress, perhaps via a Lit component or a small Vue state in that component).
- Modal dialogs and dynamic content loading for some flows (for example, viewing details of a record could be a modal rather than a new page, if appropriate, to speed up user workflow – we can fetch details via API and show in modal).
- Use of icons (with an icon library or SVGs) and clear typography to make the app more visually appealing than the likely older design.
- Ensure the app is **responsive**: the old app might not be mobile-friendly if it was WebForms. We will use our CSS framework (Tailwind/Bootstrap) grid and components to make sure pages work on various screen sizes. Test key pages on a mobile layout, adjusting components (maybe use Vue to implement a responsive table that collapses into cards, etc.).
## <a name="x46c7c799c591f2f1215d67c85cf0a90994394b1"></a>Session-Based Authentication & Authorization
A dedicated plan for authentication is crucial, given the transition from ASP.NET’s built-in auth to our custom system:

- **User Accounts:** The new system will have a users table (with at least username, password\_hash, and perhaps a role or role\_id if using a simple role setup). We will enforce good security practices: passwords hashed with bcrypt (and a decent work factor for production). During the migration setup, we will create an initial admin user (with a known password) directly in the database or via a seed script so that the system can be accessed the first time.
- **Login Process:** We will create a login page (served at /login via a route that does not require auth). This will present a form for username and password. When the user submits:
- The request hits a controller which finds the user by username, compares the provided password with the stored hash (using bcrypt compare).
- If invalid, it will either redirect back with an error message or respond with an error (if AJAX login, though we likely do traditional form for login).
- If valid, we call req.session.regenerate() (to avoid session fixation) and then set req.session.userId = <the user’s ID> and possibly req.session.role = <user’s role>. The session middleware will set a cookie connect.sid (by default) to identify the session on subsequent requests[\[23\]](https://www.expressjs.com.cn/resources/middleware/session.html#:~:text=Create%20a%20session%20middleware%20with,). Because session data is stored server-side (in memory/SQLite), the cookie contains only a session ID, not any sensitive info.
- We then redirect the user to the post-login landing (e.g. /dashboard).
- **Maintaining Session:** On each request that requires authentication, we will check for req.session.userId. This will be done via a middleware attached to protected routes. If the ID is missing, we redirect to /login. Optionally, for API routes, we can respond with 401 JSON if not authenticated.
- **Session Expiration:** We will configure the session cookie max-age to something like 1 hour of inactivity (and possibly auto-extend if the user is active). Also, because the old system had a long timeout (sessionState timeout 360 minutes ≈ 6 hours in Web.config[\[24\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config#L80-L84)), we might consider a similar or slightly shorter duration based on security needs. We’ll communicate the timeout to users (so they know they might need to re-login after that).
- **Remember Me option:** If needed, we could implement a “remember me” that extends cookie life or uses a persistent token, but that might be beyond initial scope. Initially, a standard session will suffice.
- **Roles and Authorization:** Based on the old roles (possibly Admin, Accountant, Teacher, Librarian, etc.), we will enforce permissions:
- For example, only Admin can access the /users management page or add new teachers. Teachers might log in to see student info and enter marks, but not manage fees. Accountants might manage fees but not academic info. These roles and rules will be defined early (we can mirror what the old system did, which likely assigned roles to each user and checked in UI or code).
- Implementation: after login, we know the user’s role (from the DB). We store it in session. Then define middleware like:

  function ensureRole(role) {\
  `  `return (req, res, next) => {\
  `    `if (!req.session.userId) return res.redirect('/login');\
  `    `if (req.session.role !== role) return res.status(403).send('Forbidden');\
  `    `next();\
  `  `};\
  }

  We can apply ensureRole('admin') on admin routes. For multiple roles allowed, we could extend it to accept an array (or just check if (!roles.includes(req.session.role)) ...). This is simple and effective for our scale.
- In the frontend, we will also use role info to conditionally show/hide menu items. For instance, the template for navbar can check role == 'admin' to show the Admin panel links. This is done server-side since the server knows the role from session and passes it to the template.
- **Registration:** The old system probably created users through an admin interface (no public self-signup). We will maintain that approach: only admins can create new user accounts (e.g. when adding a teacher, we also create a user login for them). Thus, we won’t build a public “register” page for now. The flow for adding a teacher will include entering a username/password for that teacher (or we generate a password and allow them to change later). For students, if students have portal access, we might also create accounts for them (perhaps using their student ID as username and a default password that they should change). We will need a **password reset/change** mechanism: at minimum, an admin can set a new password for a user, and optionally a “change my password” page for logged-in users.
- **Audit & Logging:** To improve security oversight, we can add simple audit logging. For instance, log login attempts (especially failures) with timestamps and IP (in server logs), and keep a last login timestamp in the user record. If needed, enforce account lockout after X failed attempts (the old membership provider had configs for max invalid attempts[\[2\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config#L2-L5), which we can implement similarly by a counter in DB).
- **Testing Auth:** We will test that session cookies are set and cleared properly (using the browser dev tools or an HTTP client). We’ll test that without a session one cannot access protected endpoints (expect redirect to login). Also test multi-role: log in as a teacher and verify admin pages are inaccessible, etc.

Overall, the session-based auth will give us the same capabilities as the old system (which used cookies and server sessions via ASP.NET forms auth) but with full control in our Node app. It will be more straightforward to customize (for example, easier to integrate things like Google OAuth in the future if ever desired, or to adjust session parameters).
## <a name="x5e75537ff090d8c942032c58b8600fb60e6dbac"></a>Development Environment: CodeX Web & Testing
Given that development will occur in a cloud “CodeX web” environment, and the requirement that the app be *perfectly runnable and testable* including the database, we will take the following measures:

- **SQLite Dev DB:** We choose SQLite for development specifically because it does not require setting up a separate database server. The entire database is just a file on disk (database.sqlite for example), which is ideal for a cloud IDE/container setup. We will ensure the app can **initialize the SQLite DB schema automatically**. Possible approaches:
- If using an ORM like Prisma: running prisma migrate dev as part of a setup script can create the schema. We might integrate that into the start script or provide an npm script like npm run migrate.
- If not using a full ORM, we can include an SQL schema file and have the app on first run check if tables exist (for example, try a query on the users table, if it fails, then read and execute the SQL schema file to create tables). This gives a one-step startup.
- We will include the schema (and perhaps some initial data) in the repository (e.g., in a schema.sql file or as part of migrations directory). The README will clearly state how to set up (which hopefully is as simple as “run npm install then npm start – the app will set up the DB if not present”).
- **Using CodeX environment features:** If the environment supports environment variables or secrets, we will use those for any sensitive config (like session secret, DB connection if using MySQL later). If not, we’ll design the config such that it falls back to safe defaults (e.g. session secret auto-generated if not provided, etc., for dev convenience).
- **Testing in Dev:** We will populate the SQLite database with **sample data** for testing. For example:
- Create 1-2 admin users, a few teacher accounts, a few student records (with different classes, some fees, some library entries). This can be done via a seed script or manually through the UI once the features are implemented. Having this data helps in UI development (we can see lists and try out features).
- If feasible, we can automate seeding on every start in the dev environment (so every new session gets fresh data). Alternatively, we document how to run a seed.
- **Running the App:** In the CodeX web environment, presumably we have a way to run a Node server. We will ensure the server listens on the appropriate interface/port (often 0.0.0.0:8080 for such envs) so that the environment can preview it. We’ll put the port number in config to be flexible.
- **Hot-reloading:** During development, use Nodemon (for backend) and Vite’s dev server (for frontend assets) concurrently to get a live development experience. This might be possible in CodeX (depending on if it supports multiple processes or not). If not, manual rebuilds as needed.
- **Debugging:** We can use console.log extensively or attach a debugger if possible in the environment. Also, having good error messages (Express’s error handler can be left with stack trace in dev mode) helps catch issues.
- **Automated Testing:** Write a few basic tests:
- Unit tests for critical utility functions (e.g., a function that calculates grade from marks).
- Perhaps integration tests using something like Supertest to hit our Express routes without a browser, asserting the responses (e.g., redirect happens when not logged in, or a new student is created in DB when hitting the POST).
- These tests can be run in the CodeX environment via npm test to ensure everything passes.
- **Manual QA:** After implementing each module, manually test in the browser:
- Log in as admin, navigate to each page, verify data displays correctly (and matches DB contents).
- Try adding new records (student, teacher, etc.), then check database (or the UI list) to ensure it’s saved.
- Use the functionality as an end-user would: e.g., issue a book then return it, pay a fee and see that the balance updates, input some marks and see them on the report, etc.
- Test error cases: e.g., try to add a user with an existing username to see the validation, or try an unauthorized access (log in as teacher and attempt to access an admin URL).
- Test the session timeout (if we can simulate or wait) to see that it forces login again.
- Because the environment is likely ephemeral, also test a full restart of the app: does it properly read the SQLite file and everything still works? If using an in-memory SQLite (an option), that would lose data on restart, so better to use file-based for persistence during a session.
- **Performance in Dev:** The CodeX environment might have limited resources, so we keep an eye on memory/CPU. Express and SQLite are lightweight enough; Vue/Lit are only in browser. Avoiding heavy computations on server is important (most of our tasks are I/O bound, which is fine). If any page becomes slow (e.g., listing thousands of records), we might implement pagination immediately to avoid lag in dev environment.
- **Documentation:** As part of the plan, we will maintain clear documentation (likely a README) for how to run the dev environment. This includes listing any prerequisites, how to initialize the database, and how to run the development vs production build. Also, include instructions for running tests. This will make it easy for any developer (or the user) to test the app in CodeX or locally.
- **Deployment Consideration:** While dev is SQLite, in production MySQL will be used. We will test a deployment on a MySQL instance (if possible before finalizing) to ensure our ORM/queries work and that there are no SQL differences causing issues. Also ensure that things like text encoding, date handling, etc., are consistent between SQLite and MySQL.

By following this plan, we aim to produce a fully functional, modernized School\_Queens application. The new stack will improve the maintainability and extensibility of the system: features can be added or changed with less friction (thanks to clearer separation of concerns and use of popular frameworks), the UI/UX will be significantly improved for users (responsive design, interactive elements where needed), and the system will be easier to deploy and run (no dependency on Windows/IIS or stored procedure scripts). The use of an MPA with JS islands ensures we aren’t overloading the client with unnecessary scripts, aligning with best practices for web development in 2025[\[3\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=,hydration%20or%20the%20islands%20architecture)[\[6\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=1.%20Use%20a%20Node,only%20where%20necessary). Moreover, by removing legacy constraints (like the old membership provider and SP-based DAL), we give the development team full control to tailor the system to the school’s evolving needs.

## Appendix — Phase 1 Profile & Lookup Schema

To support portal-specific person records early in the migration, Prisma models now include:

- `Person` — canonical demographic profile linked to optional `Student` or `TeacherStaff` roles.
- `Student` — enrollment-specific attributes (grade level, status, admission dates) with optional `User` reference for portal
  access.
- `TeacherStaff` — unified employee table for teachers and non-instructional staff, including employment status and portal
  account linkage.
- Lookup tables (`Gender`, `StudentStatus`, `GradeLevel`, `StaffType`, `EmploymentStatus`) to preserve flexibility for future
  UI management screens without hard-coded enums.

Seeding assumptions:

- Lookup tables are populated with representative baseline values and may be safely extended in later phases.
- Sample records (`PER-0001` student, `PER-1001` teacher) exercise both sides of the `Person` relationships and tie back to
  their Prisma `User` accounts.
- Additional environment variables (`SEED_TEACHER_PASSWORD`, `SEED_STAFF_PASSWORD`, `SEED_STUDENT_PASSWORD`) mirror the existing
  admin override so seeded credentials remain configurable across environments.

These changes maintain SQLite/MySQL compatibility (no provider-specific column types) and provide the groundwork for Phase 2
student/teacher management features without needing disruptive refactors later.

**References:**

- Current system uses stored procedures for data access (see \_cmd.CommandType = CommandType.StoredProcedure in the legacy DatabaseManager)[\[1\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/App_Code/DatabaseManager.cs#L116-L124). The migration will eliminate these in favor of application-level logic.
- Legacy authentication was based on ASP.NET SqlMembershipProvider[\[2\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config#L2-L5) and related tables. The new system will implement a custom session-based auth with Express sessions.
- MPA with partial hydration (JS islands) approach is recommended for adding interactivity without a full SPA, yielding fast initial loads and selective use of JavaScript[\[3\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=,hydration%20or%20the%20islands%20architecture)[\[6\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=1.%20Use%20a%20Node,only%20where%20necessary).
- Vue 3 can be integrated incrementally into a multi-page app, allowing interactive “islands” within server-rendered pages[\[5\]](https://vuejs.org/guide/extras/ways-of-using-vue#:~:text=%2A%20A%20multi,inside%20static%20HTML). We leverage this capability for features like dynamic forms and tables.
- Lit provides a way to create fast, lightweight web components that work with any framework or even static HTML, ideal for progressively enhancing our pages[\[8\]](https://lit.dev/docs/#:~:text=The%20first%20thing%20to%20know,framework%20or%20none%20at%20all). This ensures we can build reusable UI elements and integrate them seamlessly into the Express-rendered HTML.
-----
<a name="citations"></a>[\[1\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/App_Code/DatabaseManager.cs#L116-L124) [\[19\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/App_Code/DatabaseManager.cs#L156-L164) DatabaseManager.cs

<https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/App_Code/DatabaseManager.cs>

[\[2\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config#L2-L5) [\[20\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config#L26-L31) [\[24\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config#L80-L84) Web.config

<https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/Web.config>

[\[3\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=,hydration%20or%20the%20islands%20architecture) [\[4\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=,Highly%20customized%20data%20filtering%2Fsorting) [\[6\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=1.%20Use%20a%20Node,only%20where%20necessary) [\[10\]](https://rust-on-nails.com/blog/mpa-vs-spa/#:~:text=DaisyUI%20is%20built%20on%20Tailwind,JavaScript%20for%20its%20core%20functionality) MPA vs SPA in 2025: A Senior Architect’s Perspective

<https://rust-on-nails.com/blog/mpa-vs-spa/>

[\[5\]](https://vuejs.org/guide/extras/ways-of-using-vue#:~:text=%2A%20A%20multi,inside%20static%20HTML) [\[7\]](https://vuejs.org/guide/extras/ways-of-using-vue#:~:text=Vue%20can%20be%20used%20as,of%20jQuery%20in%20such%20cases) Ways of Using Vue | Vue.js

<https://vuejs.org/guide/extras/ways-of-using-vue>

[\[8\]](https://lit.dev/docs/#:~:text=The%20first%20thing%20to%20know,framework%20or%20none%20at%20all) [\[9\]](https://lit.dev/docs/#:~:text=Lit%20is%20a%20simple%20library,building%20fast%2C%20lightweight%20web%20components) [\[22\]](https://lit.dev/docs/#:~:text=web%20component,framework%20or%20none%20at%20all) What is Lit? – Lit

<https://lit.dev/docs/>

[\[11\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L72-L81) [\[12\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L106-L115) [\[13\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L212-L217) [\[14\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L117-L125) [\[15\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L189-L197) [\[16\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L99-L103) [\[17\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L101-L105) [\[18\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L92-L95) [\[21\]](https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql#L181-L189) add\_employee\_saddam.sql

<https://github.com/ariful19/school_queens/blob/ca280a23b4dcb43b734f47924ffbec7dc855e033/tmp/add_employee_saddam.sql>

[\[23\]](https://www.expressjs.com.cn/resources/middleware/session.html#:~:text=Create%20a%20session%20middleware%20with,) Express session middleware

<https://www.expressjs.com.cn/resources/middleware/session.html>
